#!/usr/bin/env bash

# Clean targets:
#
# 1. > clean temp[orary] - removes files from ./temporary except for .githolder
#
# 2. General clean targets:
#
#    > clean all # removes all things make built, and thus can be replaced by running make again.
#    > clean program # removes all built executor scripts and corresponding jar files
#    > clean class # removes the class files
#    > clean grammar # removes the generated java grammar files
#
# 3. Specific clean targets:
#
#    > clean all <program_name> # cleans all files built while building the program
#    > clean program <program_name> # removes the script and jar file for the given program
#    > clean grammar <grammar_name> - similar to clean:grammar, but only for the named grammar

# Function to display usage message
display_usage() {
  echo "Usage: clean <all [<program_name>] | program [<program_name>] | grammar [<name>] | class | temp[orary]>"
}

# Function to clean a directory
clean_directory() {
  local dir="$1"
  find "$dir" -type f ! -name '.githolder' -exec rm -f {} +
}

# Function to check if a program is in PROGRAM_FPL
is_program_in_fpl() {
  local program="$1"
  for prog in $PROGRAM_FPL; do
    if [[ "$prog" == *"$program"* ]]; then
      return 0
    fi
  done
  return 1
}

# Function to delete a program
delete_program() {
  local program="$1"
  if is_program_in_fpl "$program"; then
    echo "Deleting program files for '$program'"
    rm -f "executor/$program" "$JAVA_COMP_OUT_DIR/$program.jar" "$JAVA_COMP_OUT_DIR/$program.class"
  else
    echo "Error: Program '$program' is not recognized or is not listed in PROGRAM_FPL."
    return 1
  fi
}

# Command parser
clean_command_parser() {
  local token_list=($@)
  local token_count=${#token_list[@]}
  local command=${token_list[0]}
  local arg=${token_list[1]}

  if [ "$token_count" -eq 0 ]; then
    display_usage
  elif [ "$token_count" -eq 1 ]; then
    case "$command" in
      "temporary" | "temp")
        clean_directory "$TEMP_DIR"
        ;;
      "all")
        clean_directory "$TEMP_DIR"
        clean_grammar
        clean_file_list "JAVA_COMP_OUT_FPL"
        clean_file_list "JAR_OUT_FPL"
        clean_file_list "PROGRAM_FPL"
        ;;
      "program")
        clean_file_list "JAR_OUT_FPL"
        clean_file_list "PROGRAM_FPL"
        ;;
      "class")
        clean_file_list "JAVA_COMP_OUT_FPL"
        ;;
      "grammar")
        clean_grammar
        ;;
      *)
        echo "Unknown clean option: $command"
        ;;
    esac
  elif [ "$token_count" -eq 2 ]; then
    case "$command" in
      "all")
        # Program name is $arg.
        delete_program "$arg"
        # Custom cleaning for each program.
        case "$arg" in
          "SyntaxTree_Test")
            clean_grammar "GQL_Test"
            ;;
          "SyntaxTree_20240412")
            clean_grammar "GQL_20240412"
            ;;
          "PrintRuleNameList")
            : 
            ;;
          *)
            echo "Unknown program: $arg"
            ;;
        esac
        ;;
      "program")
        # Program name is $arg.
        delete_program "$arg"
        ;;
      "grammar")
        # Grammar name is $arg.
        clean_grammar "$arg"
        ;;
      *)
        echo "Unknown clean command: $command"
        ;;
    esac
  else
    echo "Clean commands are at most two tokens, but we found: $token_count"
  fi
}

source env_build
clean_command_parser $@
