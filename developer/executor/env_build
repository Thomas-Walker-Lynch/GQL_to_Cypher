#!/usr/bin/env bash

# The build environment. 
#
# Hopefully no edits are required here to build this project's programs.
#
# The most common edit here is to add the name of a new program to the EXECUTOR_IN_FL.
# That variable is found in the next section.
#
# The `env_dev` script should have been sourced already. (env_dev is analogous
# to the Python virutal environment `activate`.)  `env_dev` will set `developer/executor/`
# first in the search PATH.  In that directory there is a script called `make` which
# is a wrapper to `/bin/make`.  That script sources this file.  Hence, this file
# is the environment for make, aka the build environment.
#
# Note these suffixes found on variable names:
# _FL  = File List
# _FP  = File Path
# _FPL = File Path List 
# _DL  = Directory List
# _DP  = Directory path
# _DPL = Directory path list
#
# _PRIMARY = stuff not built
# _IN  things input to some program
# _OUT things output by some program
#
# Relative paths values are relative to the $REPO_HOME/developer directory, unless
# for good reason which is obvious or stated in a comment adjacent to the variable.
#
# This has not yet been split into 'tools'  and 'project'. The redundant build targets
# should discovered to have already been built.

# Ensure the script is sourced rather than run directly
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  echo "This script must be sourced, not executed. Exiting."
  return 1
fi

#--------------------------------------------------------------------------------
# programs to be built by make project-all (or more simply `make`)
#

export EXECUTOR_IN_FL="\
  RuleNameListRegx\
  RuleNameList\
  Synthesize_SyntaxAnnotate_PrintVisitorMethod\
  Synthesize_SyntaxAnnotate_PrintVisitor\
  Synthesize_SyntaxAnnotate\
  ANTLRv4_RuleNameList\
  Arithmetic_Echo\
  Arithmetic_Echo__Test\
  Arithmetic_SyntaxAnnotate\
  Arithmetic_SyntaxAnnotate__Test\
  Arithmetic2_SyntaxAnnotate\
  Arithmetic2_SyntaxAnnotate__Test\
  ANTLRv4_SyntaxAnnotate\
  "

# where make will put the programs
export EXECUTOR_IN_DIR="executor"

# Generate the EXECUTOR_IN_FPL list
export EXECUTOR_IN_FPL=$(for program in $EXECUTOR_IN_FL; do echo "${EXECUTOR_IN_DIR}/${program}"; done | tr '\n' ' ')

#--------------------------------------------------------------------------------
# developer build directories
#

# ANTLR directories
export ANTLR_IN_PRIMARY_DIR="ANTLR"
export ANTLR_OUT_DIR="javac/ANTLR"
export ANTLR_OUT_DIR_PARENT="javac"

# JAVA directories
export JAVA_COMP_IN_PRIMARY_DIR="javac"
export JAVA_COMP_IN_ANTLR_DIR="${ANTLR_OUT_DIR}"
export JAVA_COMP_IN_DL="${JAVA_COMP_IN_PRIMARY_DIR}:${JAVA_COMP_IN_ANTLR_DIR}"
export JAVA_COMP_OUT_DIR="jvm"

# JVM
export JVM_IN_DIR="${JAVA_COMP_OUT_DIR}"

# The generated build scripts might need arguments that are fully specified paths.
export DEVELOPER_HOME_DP="/var/user_data/Thomas-developer/GQL_to_Cypher/developer"
export JVM_IN_DP="$DEVELOPER_HOME_DP/jvm"
export EXECUTOR_IN_DP="$DEVELOPER_HOME_DP/executor"
export CLASSPATH="${CLASSPATH}:${JVM_IN_DP}"

#--------------------------------------------------------------------------------
# tools used
#
#  set by project manager: JAVA_HOME, ANTLR_JAR, DEVELOPER_HOME
#
export BIN_MAKE=/bin/make
export JAVA_COMP="${JAVA_HOME}/bin/javac"
export JAVA_INTERP="${JAVA_HOME}/bin/java"
export JAVA_ARCHIVE="${JAVA_HOME}/bin/jar"
export CLASSPATH="${CLASSPATH}:$ANTLR_JAR"

#--------------------------------------------------------------------------------
# misc
#
export TEMP_DIR="$DEVELOPER_HOME"/temporary

#--------------------------------------------------------------------------------
# ANTLR files
#
export ANTLR_IN_PRIMARY_FPL=$(ls ${ANTLR_IN_PRIMARY_DIR}/*.g4 2>/dev/null | tr '\n' ' ')
export ANTLR_GRAMMAR_LIST=$(basename -s .g4 ${ANTLR_IN_PRIMARY_FPL})
if [ -z "${ANTLR_IN_PRIMARY_FPL}" ]; then
  echo "No ANTLR input grammar files found"
fi

#--------------------------------------------------------------------------------
# Java files 
#

# JAVA input files
export JAVA_COMP_IN_PRIMARY_FPL=$(ls ${JAVA_COMP_IN_PRIMARY_DIR}/*.java 2>/dev/null | tr '\n' ' ')
export JAVA_COMP_IN_ANTLR_FPL=${ANTLR_OUT_FPL}
export JAVA_COMP_IN_FPL="${JAVA_COMP_IN_PRIMARY_FPL} ${JAVA_COMP_IN_ANTLR_FPL}"

# JAVA will produce these output files
export JAVA_COMP_OUT_PRIMARY_FPL=$(echo ${JAVA_COMP_IN_PRIMARY_FPL} | sed "s|${JAVA_COMP_IN_PRIMARY_DIR}/|${JAVA_COMP_OUT_DIR}/|g" | sed "s|.java|.class|g")
export JAVA_COMP_OUT_ANTLR_FPL=$(echo ${JAVA_COMP_IN_ANTLR_FPL} | sed "s|${JAVA_COMP_IN_ANTLR_DIR}/|${JAVA_COMP_OUT_DIR}/|g" | sed "s|.java|.class|g")
export JAVA_COMP_OUT_FPL="${JAVA_COMP_OUT_PRIMARY_FPL} ${JAVA_COMP_OUT_ANTLR_FPL}"
#--------------------------------------------------------------------------------
# JAR files
#

# List of JAR files to be built
JAR_OUT_FPL=""
for program_path in ${EXECUTOR_IN_FPL}; do
  program_name=$(basename ${program_path})
  class_file="${JAVA_COMP_OUT_DIR}/${program_name}.class"
  # Check if the .class file is in JAVA_COMP_OUT_FPL
  for item in ${JAVA_COMP_OUT_FPL}; do
    # if so add it to the JAR_OUT_FPL
    if [[ "${item}" == "${class_file}" ]]; then
      jar_file="${JAVA_COMP_OUT_DIR}/${program_name}.jar"
      JAR_OUT_FPL="${JAR_OUT_FPL} ${jar_file}"
      break
    fi
  done
done
export JAR_OUT_FPL


#  LocalWords:  ANTLRv PrintRuleNameListRegx RuleNameListRegx RuleNameList
#  LocalWords:  PrintVisitorMethod PrintVisitor SyntaxAnnotate
