#!/usr/bin/env bash

# Ensure the script is sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  echo "This script must be sourced, not executed. Exiting."
  return 1
fi

# Note these suffixes:
# _FL  = File List
# _FP  = File Path
# _FPL = File Path List 
# _DL  = Directory List
# _DP  = Directory path
# _DPL = Directory path list

# _PRIMARY = stuff not built
# _IN  things input to some program
# _OUT things output by some program

#--------------------------------------------------------------------------------
# to be built

# export PROGRAM_PrintRuleNameList="executor/PrintRuleNameList"
# export PROGRAM_SyntaxTree_Arithmetic="executor/SyntaxTree_Arithmetic"
# export PROGRAM_Test__SyntaxTree_Arithmetic="executor/Test__SyntaxTree_Arithmetic"
# export PROGRAM_SyntaxTree_20240412="executor/SyntaxTree_20240412"


# Add each new executable to this list, and give it a custom target in the makefile.
export EXECUTOR_IN_FL="\
  PrintRuleNameList\
  TerminalToCategory\
  GrammarSplitter\
  Arithmetic_Echo\
  Arithmetic_Echo__Test\
  Arithmetic_Syntax\
  Arithmetic_Syntax__Test\
  GQL_20240412_Syntax\
  GQL_20240412_Syntax__Test\
  "

# where make will put the programs
export EXECUTOR_IN_DIR="executor"

# Generate the EXECUTOR_IN_FPL list
export EXECUTOR_IN_FPL=$(for program in $EXECUTOR_IN_FL; do echo "${EXECUTOR_IN_DIR}/${program}"; done | tr '\n' ' ')

#--------------------------------------------------------------------------------
# build directories
#

# ANTLR directories
export ANTLR_IN_PRIMARY_DIR="ANTLR"
export ANTLR_OUT_DIR="javac/ANTLR"
export ANTLR_OUT_DIR_PARENT="javac"

# JAVA directories
export JAVA_COMP_IN_PRIMARY_DIR="javac"
export JAVA_COMP_IN_ANTLR_DIR="${ANTLR_OUT_DIR}"
export JAVA_COMP_IN_DL="${JAVA_COMP_IN_PRIMARY_DIR}:${JAVA_COMP_IN_ANTLR_DIR}"
export JAVA_COMP_OUT_DIR="jvm"

# JVM
export JVM_IN_DIR="${JAVA_COMP_OUT_DIR}"

# The generated build scripts might need arguments that are fully specified paths.
export DEVELOPER_HOME_DP="/var/user_data/Thomas-developer/GQL_to_Cypher/developer"
export JVM_IN_DP="$DEVELOPER_HOME_DP/jvm"
export EXECUTOR_IN_DP="$DEVELOPER_HOME_DP/executor"
export CLASSPATH="${CLASSPATH}:${JVM_IN_DP}"

#--------------------------------------------------------------------------------
# tools used
#
#  set by project manager: JAVA_HOME, ANTLR_JAR, DEVELOPER_HOME
#
export JAVA_COMP="${JAVA_HOME}/bin/javac"
export JAVA_INTERP="${JAVA_HOME}/bin/java"
export JAVA_ARCHIVE="${JAVA_HOME}/bin/jar"
export CLASSPATH="${CLASSPATH}:$ANTLR_JAR"

#--------------------------------------------------------------------------------
# misc
#
export TEMP_DIR="$DEVELOPER_HOME"/temporary

#--------------------------------------------------------------------------------
# ANTLR files
#

export ANTLR_IN_PRIMARY_FPL=$(ls ${ANTLR_IN_PRIMARY_DIR}/*.g4 2>/dev/null | tr '\n' ' ')
export ANTLR_GRAMMAR_LIST=$(basename -s .g4 ${ANTLR_IN_PRIMARY_FPL})
if [ -z "${ANTLR_IN_PRIMARY_FPL}" ]; then
  echo "No ANTLR input grammar files found"
fi

# replaced with a tool called ANTLR_OUR_FL
#
# This function accepts a grammar name, or a grammar name with an extension; 
# and sets a variable of the form ANTLR_OUT_<grammar>_FPL to a list of
# files that ANTLR would produce for <grammar>.
# set_ANTLR_out_fpl_var() {
#  local grammar=$1
#  export ANTLR_OUT_${grammar}_FPL="${ANTLR_OUT_DIR}/${grammar}Lexer.java ${ANTLR_OUT_DIR}/${grammar}Parser.java ${ANTLR_OUT_DIR}/${grammar}BaseVisitor.java ${ANTLR_OUT_DIR}/${grammar}Visitor.java"
# }

# Generate ANTLR_OUT_<grammar>_FPL for each grammar
# for grammar in ${ANTLR_GRAMMAR_LIST}; do
#  set_ANTLR_out_fpl_var ${grammar}
# done

# Combine all individual file lists into ANTLR_OUT_FPL
# ANTLR_OUT_FPL=""
# for grammar in ${ANTLR_GRAMMAR_LIST}; do
#   ANTLR_OUT_FPL="${ANTLR_OUT_FPL} $(eval echo \$ANTLR_OUT_${grammar}_FPL)"
# done
# export ANTLR_OUT_FPL

#--------------------------------------------------------------------------------
# Java files 
#

# JAVA input files
export JAVA_COMP_IN_PRIMARY_FPL=$(ls ${JAVA_COMP_IN_PRIMARY_DIR}/*.java 2>/dev/null | tr '\n' ' ')
export JAVA_COMP_IN_ANTLR_FPL=${ANTLR_OUT_FPL}
export JAVA_COMP_IN_FPL="${JAVA_COMP_IN_PRIMARY_FPL} ${JAVA_COMP_IN_ANTLR_FPL}"

# JAVA will produce these output files
export JAVA_COMP_OUT_PRIMARY_FPL=$(echo ${JAVA_COMP_IN_PRIMARY_FPL} | sed "s|${JAVA_COMP_IN_PRIMARY_DIR}/|${JAVA_COMP_OUT_DIR}/|g" | sed "s|.java|.class|g")
export JAVA_COMP_OUT_ANTLR_FPL=$(echo ${JAVA_COMP_IN_ANTLR_FPL} | sed "s|${JAVA_COMP_IN_ANTLR_DIR}/|${JAVA_COMP_OUT_DIR}/|g" | sed "s|.java|.class|g")
export JAVA_COMP_OUT_FPL="${JAVA_COMP_OUT_PRIMARY_FPL} ${JAVA_COMP_OUT_ANTLR_FPL}"
#--------------------------------------------------------------------------------
# JAR files
#

# List of JAR files to be built
JAR_OUT_FPL=""
for program_path in ${EXECUTOR_IN_FPL}; do
  program_name=$(basename ${program_path})
  class_file="${JAVA_COMP_OUT_DIR}/${program_name}.class"
  # Check if the .class file is in JAVA_COMP_OUT_FPL
  for item in ${JAVA_COMP_OUT_FPL}; do
    # if so add it to the JAR_OUT_FPL
    if [[ "${item}" == "${class_file}" ]]; then
      jar_file="${JAVA_COMP_OUT_DIR}/${program_name}.jar"
      JAR_OUT_FPL="${JAR_OUT_FPL} ${jar_file}"
      break
    fi
  done
done
export JAR_OUT_FPL

