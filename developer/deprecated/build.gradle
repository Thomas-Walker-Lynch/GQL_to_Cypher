// OpenAI assisted generation from the makefile .. a start on a gradle build file

plugins {
    id 'java'
}

group 'com.example'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.antlr:antlr4:4.9.2'  // Include the ANTLR runtime library
    testImplementation 'junit:junit:4.12'    // Include JUnit for testing
}

// Define environment variables
def javaHome = System.getenv('JAVA_HOME')
def antlrJar = file(System.getenv('ANTLR_JAR'))

// Define directories
def antlrPrimaryDir = 'ANTLR'
def antlrInDir = "${antlrPrimaryDir}"
def antlrOutDir = 'javac/ANTLR'
def antlrOutDirParent = 'javac'
def tempDir = 'temporary'
def executorDir = 'executor'
def jvmOutDir = 'jvm'

// Define program paths
def programPrintRuleNameList = "${executorDir}/PrintRuleNameList"
def programSyntaxTreeTest = "${executorDir}/SyntaxTree_Test"
def programSyntaxTree20240412 = "${executorDir}/SyntaxTree_20240412"

// Define grammar files
def grammarFiles = fileTree(dir: antlrInDir, include: '**/*.g4')

// Task to set up directories
task setup {
    doLast {
        mkdir antlrInDir
        mkdir antlrOutDirParent
        mkdir 'javac'
        mkdir jvmOutDir
        mkdir executorDir
        mkdir 'test'
        mkdir 'deprecated'
        mkdir 'experiment'
        mkdir 'documentation'
        mkdir tempDir
    }
}

// Function to generate grammar tasks
def generateGrammarTask(String grammarName) {
    task "generate${grammarName}Grammar" {
        inputs.file file("${antlrInDir}/${grammarName}.g4")
        outputs.dir antlrOutDir

        doLast {
            println "Generating grammar files for: ${grammarName}"
            exec {
                commandLine "${javaHome}/bin/java", '-jar', antlrJar, '-Dlanguage=Java', '-visitor', '-o', antlrOutDirParent, file("${antlrInDir}/${grammarName}.g4")
            }
        }
    }
}

// Generate grammar tasks for each grammar file
grammarFiles.each { File file ->
    def grammarName = file.name.replace('.g4', '')
    generateGrammarTask(grammarName)
}

// Define source sets
sourceSets {
    main {
        java {
            srcDirs = ['javac', antlrOutDir]
        }
    }
}

// Task to compile Java files
task compileJava(type: JavaCompile) {
    source = sourceSets.main.java
    classpath = sourceSets.main.compileClasspath
    destinationDir = file(jvmOutDir)
}

// Task to build JAR file
task buildJar(type: Jar) {
    from compileJava.destinationDir
    archiveBaseName.set('project')
    destinationDirectory.set(file(jvmOutDir))
}

// Task to create an executable script
task createScript {
    dependsOn buildJar

    doLast {
        def jarFile = buildJar.archiveFile.get().asFile
        def scriptFile = file("${executorDir}/${project.name}")

        scriptFile.text = """#!/usr/bin/env bash
${javaHome}/bin/java -cp ${jarFile} ${project.name}
"""
        scriptFile.setExecutable(true)
    }
}

// Task to clean generated files
task clean(type: Delete) {
    delete antlrOutDir
    delete jvmOutDir
    delete tempDir
    delete programPrintRuleNameList
    delete programSyntaxTreeTest
    delete programSyntaxTree20240412
    delete fileTree(dir: executorDir, exclude: '.githolder')
}

// Task to print version information
task printVersion {
    doLast {
        println "ANTLR Jar: ${antlrJar.name}"
        println "Java version: ${javaHome}/bin/java -version".execute().text
        println "Jar version: ${javaHome}/bin/jar --version".execute().text
        println "Gradle version: ${gradle.gradleVersion}"
    }
}

// Default tasks
defaultTasks 'setup', 'generateGQLGrammar', 'compileJava', 'buildJar', 'createScript'

// Set encoding for JavaCompile tasks
tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

// Task to build everything
task all {
    dependsOn setup, 'generateGQLGrammar', compileJava, buildJar, createScript
}

// Task to generate grammar files
task grammar {
    dependsOn setup, 'generateGQLGrammar'
}

// Task to compile Java files
task java {
    dependsOn setup, compileJava
}

// Task to clean temporary files
task cleanTemporary(type: Delete) {
    delete tempDir
}

// Task to clean all files
task cleanAll {
    dependsOn clean
}

// Task to clean all files except program files
task cleanAllMinus {
    doLast {
        delete tempDir
        delete antlrOutDir
        delete fileTree(dir: jvmOutDir, include: '**/*.class')
    }
}

// Task to clean program files
task cleanProgram {
    doLast {
        delete programPrintRuleNameList
        delete programSyntaxTreeTest
        delete programSyntaxTree20240412
    }
}

// Task to clean class files
task cleanClass {
    doLast {
        delete fileTree(dir: jvmOutDir, include: '**/*.class')
    }
}

// Task to clean grammar files
task cleanGrammar {
    doLast {
        delete fileTree(dir: antlrOutDir, include: '**/*.java')
    }
}

// Task to clean a specific program
task cleanProgramSpecific {
    doLast {
        def programName = project.findProperty('program') ?: ''
        if (programName) {
            delete fileTree(dir: jvmOutDir, include: "${programName}.jar")
            delete fileTree(dir: executorDir, include: "${programName}")
        } else {
            println "Usage: gradle cleanProgramSpecific -Pprogram=<name>"
        }
    }
}

// Task to clean a specific program and everything else
task cleanProgramPlusSpecific {
    doLast {
        def programName = project.findProperty('program') ?: ''
        if (programName) {
            delete fileTree(dir: jvmOutDir, include: "${programName}.jar")
            delete fileTree(dir: executorDir, include: "${programName}")
            delete tempDir
            delete antlrOutDir
        } else {
            println "Usage: gradle cleanProgramPlusSpecific -Pprogram=<name>"
        }
    }
}

// Task to clean a specific program and everything else except program files
task cleanProgramMinusSpecific {
    doLast {
        def programName = project.findProperty('program') ?: ''
        if (programName) {
            delete fileTree(dir: jvmOutDir, include: "${programName}.jar")
            delete fileTree(dir: executorDir, include: "${programName}")
            delete tempDir
            delete fileTree(dir: jvmOutDir, include: '**/*.class')
        } else {
            println "Usage: gradle cleanProgramMinusSpecific -Pprogram=<name>"
        }
    }
}

// Task to clean a specific grammar
task cleanGrammarSpecific {
    doLast {
        def grammarName = project.findProperty('grammar') ?: ''
        if (grammarName) {
            delete fileTree(dir: antlrOutDir, include: "${grammarName}*")
        } else {
            println "Usage: gradle cleanGrammarSpecific -Pgrammar=<name>"
        }
    }
}

// Define tasks for each program
task buildPrintRuleNameList {
    dependsOn setup, 'generateGQLGrammar', compileJava
}

task buildSyntaxTreeTest {
    dependsOn setup, 'generateSyntaxTreeGrammar', compileJava
}

task buildSyntaxTree20240412 {
    dependsOn setup, 'generateSyntaxTree20240412Grammar', compileJava
}
