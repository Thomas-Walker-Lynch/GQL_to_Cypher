# 1. clean:temporary  - removes files from ./temporary
# 2. General clean targets:
#      clean:all  - removes all things make built, and thus can be replaced by running make again.
#      clean:all-   (minus after the all)  same as clean:all except for the program files (and their .jar if any)
#      clean:program -  all program files, i.e. ./exector/<program>   and ./jvm/<program.jar>  for all programs.
#      clean:class - class files
#      clean:grammar - all generated grammar files
     
# 2. 
#     clean:program:<name>
#     similear to clean:program, but only for the named program

#     clean:program+:<name>
#     bascially clean:all but only for the named program

#     clean:program-:<mame>
#     baiscally clean:all- but only for the named program

# 3. clean:grammar:<name>
#     siimilar to clean:grammar, but only for the named grammar	

# Function to clean a list of files
# Accepts a list of files as an argument and deletes the files in the list
# without complaining if a file is not found
define clean_files
  echo "Cleaning files: $1";\
  for file in $1; do \
    if [ -e "$$file" ]; then \
      echo rm -f "$$file"; \
      rm -f "$$file"; \
    fi; \
  done
endef


# Function to clean the contents of a directory
# Accepts a directory as an argument, checks that the argument is not empty,
# ensures the directory exists, and then deletes the contents of the directory
# (excluding a file called .githolder)
define clean_directory
  if [ -z "$1" ]; then \
    echo "Error: Directory argument is empty"; \
  elif [ ! -d "$1" ]; then \
    echo "Error: Directory $1 does not exist"; \
  else \
    : echo "Cleaning directory: $1"; \
    find "$1" -mindepth 1 -maxdepth 1 ! -name '.githolder' -exec rm -rf {} +; \
    touch "$1/.githolder"; \
  fi
endef

# Function to handle individual cleaning
# Accepts a single option and removes the appropriate files
define do_clean
  echo "Cleaning files for option: $1";\
  if [ "$1" = "" ]; then \
    echo "Usage: make clean:< all[-] | program[+/-][:<name>] | grammar[:<name>] | class | temp[orary] >"; \
  elif [ "$1" = "temporary" -o "$1" = "temp" ]; then \
    $(call clean_directory,$(TEMP_DIR)); \
  elif [ "$1" = "all" ]; then \
    $(call clean_directory,$(TEMP_DIR)); \
    $(call clean_files,$(ANTLR_OUT_FPL)); \
    $(call clean_files,$(JAVA_COMP_OUT_FPL)); \
    $(call clean_files,$(PROGRAM_FPL)); \
  elif [ "$1" = "all-" ]; then \
    $(call clean_directory,$(TEMP_DIR)); \
    $(call clean_files,$(ANTLR_OUT_FPL)); \
    $(call clean_files,$(JAVA_COMP_OUT_PRIMARY_FPL)); \
  elif [ "$1" = "program" ]; then \
    $(call clean_files,$(PROGRAM_FPL)); \
  elif [ "$1" = "class" ]; then \
    $(call clean_files,$(JAVA_COMP_OUT_FPL)); \
  elif [ "$1" = "grammar" ]; then \
    $(call clean_files,$(ANTLR_OUT_FPL)); \
  elif [ "$1" = "program:"* ]; then \
    program_name=$${1#program:}; \
    $(call clean_files,$(JAVA_COMP_OUT_DIR)/$${program_name}.jar executor/$${program_name}); \
  elif [ "$1" = "program+:"* ]; then \
    program_name=$${1#program+:}; \
    $(call clean_files,$(JAVA_COMP_OUT_DIR)/$${program_name}.jar executor/$${program_name}); \
    $(call clean_directory,$(TEMP_DIR)); \
    $(call clean_files,$(ANTLR_OUT_FPL)); \
  elif [ "$1" = "program-:"* ]; then \
    program_name=$${1#program-:}; \
    $(call clean_files,$(JAVA_COMP_OUT_DIR)/$${program_name}.jar executor/$${program_name}); \
    $(call clean_directory,$(TEMP_DIR)); \
    $(call clean_files,$(JAVA_COMP_OUT_PRIMARY_FPL)); \
  elif [ "$1" = "grammar:"* ]; then \
    grammar_name=$${1#grammar:}; \
    $(call clean_files,$(ANTLR_OUT_DIR)/$${grammar_name}*); \
  else \
    echo "Unknown clean option: $1"; \
  fi
endef

# Default clean target
.PHONY: clean
clean:
	@echo "Usage: make clean:< all[-] | program[+/-][:<name>] | grammar[:<name>] | class | temp[orary] >"

# Clean specific program or option
# Calls the do_clean function with the pattern as an argument
.PHONY: clean\:%
clean\:%:
	@$(call do_clean,$*)
