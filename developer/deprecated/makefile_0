# GQL_to_Cypher makefile

#================================================================================
# Setup the environment
#
# Use `make variable` to print the value assigned to the variables in this section

#----------------------------------------
# some notes about setting variables. Save yourself some grief by reading this.
#

# An example of setting a make variable. Embedded and trailing spaces are
# included in the value, there are 4 of each present in the value for
# ISLAND. Leading spaces are not included.  If there is a comment starting with
# a hash, the trailing spaces leading up to it the hash will be included in the
# value. A `:=` will evaluate immediately. A `=` will evaluate at point of variable
# expansion.
ISLAND :=    land    island    

# Note these abbreviations:
# FL = File List, out file lists are those we want make to create
# DL = Directory List

#----------------------------------------
# programs used by this makefile
#
JAVA_COMP    := $(JAVA_HOME)/bin/javac
JAVA_INTERP  := $(JAVA_HOME)/bin/java
JAVA_ARCHIVE := $(JAVA_HOME)/bin/jar

#----------------------------------------
# programs being built by this makefile:
#
PRINT_RULE_NAME_LIS  := PrintRuleNameList
SYNTAX_TREE_TEST     := SyntaxTree_Test
SYNTAX_TREE_20240412 := SyntaxTree_20240412
# put your version here

PROGRAM_LIST         := $(PRINT_RULE_NAME_LIST) $(SYNTAX_TREE_TEST) $(SYNTAX_TREE_20240412)

#----------------------------------------
# ANTLR environment

# ANTLR directories
ANTLR_IN_DIR  := ANTLR
ANTLR_OUT_DIR := javac/ANTLR
ANTLR_OUT_DIR_PARENT := javac

# ANTLR input files
ANTLR_IN_FL := $(wildcard $(ANTLR_IN_DIR)/*.g4)
ifneq ($(strip $(ANTLR_IN_FL)),)
  ($info empty ANTLR_IN_FL)
endif

# ANTLR will produce these output files. 

# This function accepts a grammar name, or a grammar name with an extension; 
# and sets a variable of the form ANTLR_OUT_<grammar>_FL to a list of
# files that ANTLR would produce for <grammar>.
define set_ANTLR_out_fl_var
  ANTLR_OUT_$(basename $(notdir $1))_FL := \
    $(ANTLR_OUT_DIR)/$(basename $(notdir $1))Lexer.java \
    $(ANTLR_OUT_DIR)/$(basename $(notdir $1))Parser.java \
    $(ANTLR_OUT_DIR)/$(basename $(notdir $1))BaseVisitor.java \
    $(ANTLR_OUT_DIR)/$(basename $(notdir $1))Visitor.java
endef

# Generate an ANTLR_OUT_<grammar>_FL and set it, for each grammar
$(foreach file,$(ANTLR_IN_FL),$(eval $(call set_ANTLR_out_fl_var,$(file))))

# Combine all individual file lists into ANTLR_OUT_FL
ANTLR_OUT_FL := $(foreach file,$(ANTLR_IN_FL),$(value ANTLR_OUT_$(basename $(notdir $(file)))_FL))


#----------------------------------------
# Java environment

# JAVA directories
JAVA_COMP_IN_PRIMARY_DIR := javac
JAVA_COMP_IN_ANTLR_DIR   := $(ANTLR_OUT_DIR)
JAVA_COMP_IN_DL          := $(JAVA_COMP_IN_PRIMARY_DIR):$(JAVA_COMP_IN_ANTLR_DIR)
JAVA_COMP_OUT_DIR        := jvm

# JAVA input files
JAVA_COMP_IN_PRIMARY_FL := $(wildcard $(JAVA_COMP_IN_PRIMARY_DIR)/*.java)
JAVA_COMP_IN_ANTLR_FL   := $(ANTLR_OUT_FL)
JAVA_COMP_IN_FL         := $(JAVA_COMP_IN_PRIMARY_FL) $(JAVA_COMP_IN_ANTLR_FL)

# JAVA will produce these output files
JAVA_COMP_OUT_PRIMARY_FL := $(patsubst $(JAVA_COMP_IN_PRIMARY_DIR)/%.java,$(JVM_IN_DIR)/%.class,$(JAVA_COMP_IN_PRIMARY_FL))
JAVA_COMP_OUT_ANTLR_FL   := $(patsubst $(JAVA_COMP_IN_ANTLR_DIR)/%.java,$(JVM_IN_DIR)/%.class,$(JAVA_COMP_IN_ANTLR_FL))
JAVA_COMP_OUT_FL         := $(JAVA_COMP_OUT_PRIMARY_FL) $(JAVA_COMP_OUT_ANTLR_FL)

#----------------------------------------
# JVM environment

JVM_IN_DIR := $(JAVA_COMP_OUT_DIR)
CLASSPATH := $(CLASSPATH):$(JVM_IN_DIR)
export CLASSPATH


#================================================================================
# Make targets
#

# The general make everything targets:
all: setup $(PROGRAM_LIST)
grammar: setup $(ANTLR_OUT_FL)

# specific programs or program versions:
PrintRuleNameList: PrintRuleNameList.jar
SyntaxTree_Test: $(ANTLR_OUT_SyntaxTree_Test_FL) SyntaxTree_Test.jar
SyntaxTree_20240412: $(ANTLR_OUT_SyntaxTree_20240412_FL) SyntaxTree_20240412.jar

# Specific grammar targets. Run them like this:
# > make <grammar_name>
# e.g. > make GQL_test
# Specific grammar targets. Run them like this:
# > make <grammar_name>
# e.g. > make GQL_test

# Specific grammar targets. Run them like this:
# > make <grammar_name>
# e.g. > make GQL_test
define generate_grammar_target
grammar_name := $(basename $(notdir $1))
$(info Generating target: $(grammar_name) with dependencies: $(value ANTLR_OUT_$(grammar_name)_FL))
$(basename $(notdir $1)): $(value ANTLR_OUT_$(basename $(notdir $1))_FL)
endef
$(foreach file,$(ANTLR_IN_FL),$(eval $(call generate_grammar_target,$(file))))


# Compile all the .java files.
java: setup $(JAVA_COMP_OUT_FL)

# print out all variables within quotes so that spaces can be detected
.PHONY: variable
variable:
	$(info ISLAND is '$(ISLAND)')

	$(info PRINT_RULE_NAME_LIST is '$(PRINT_RULE_NAME_LIST)')
	$(info SYNTAX_TREE_TEST is '$(SYNTAX_TREE_TEST)')
	$(info SYNTAX_TREE_20240412 is '$(SYNTAX_TREE_20240412)')
	$(info PROGRAM_LIST is '$(PROGRAM_LIST)')

	$(info JAVA_COMP is '$(JAVA_COMP)')
	$(info JAVA_INTERP is '$(JAVA_INTERP)')
	$(info JAVA_ARCHIVE is '$(JAVA_ARCHIVE)')

	$(info ANTLR_IN_DIR is '$(ANTLR_IN_DIR)')
	$(info ANTLR_OUT_DIR is '$(ANTLR_OUT_DIR)')
	$(info ANTLR_OUT_DIR_PARENT is '$(ANTLR_OUT_DIR_PARENT)')
	$(info ANTLR_IN_FL is '$(ANTLR_IN_FL)')
	$(foreach file,$(ANTLR_IN_FL),$(info ANTLR_OUT_$(basename $(notdir $(file)))_FL is '$(value ANTLR_OUT_$(basename $(notdir $(file)))_FL)'))
	$(info ANTLR_OUT_FL is '$(ANTLR_OUT_FL)')

	$(info JAVA_COMP_IN_PRIMARY_DIR is '$(JAVA_COMP_IN_PRIMARY_DIR)')
	$(info JAVA_COMP_IN_ANTLR_DIR is '$(JAVA_COMP_IN_ANTLR_DIR)')
	$(info JAVA_COMP_IN_DL is '$(JAVA_COMP_IN_DL)')
	$(info JAVA_COMP_OUT_DIR is '$(JAVA_COMP_OUT_DIR)')

	$(info JAVA_COMP_IN_PRIMARY_FL is '$(JAVA_COMP_IN_PRIMARY_FL)')
	$(info JAVA_COMP_IN_ANTLR_FL is '$(JAVA_COMP_IN_ANTLR_FL)')
	$(info JAVA_COMP_IN_FL is '$(JAVA_COMP_IN_FL)')

	$(info JAVA_COMP_OUT_PRIMARY_FL is '$(JAVA_COMP_OUT_PRIMARY_FL)')
	$(info JAVA_COMP_OUT_ANTLR_FL is '$(JAVA_COMP_OUT_ANTLR_FL)')
	$(info JAVA_COMP_OUT_FL is '$(JAVA_COMP_OUT_FL)')

	$(info JVM_IN_DIR is '$(JVM_IN_DIR)')
	$(info CLASSPATH is '$(CLASSPATH)')
	@:

.PHONY: version
version:
	$(info ANTLR_JAR is '$(notdir $(ANTLR_JAR))')
	@ $(JAVA_COMP) --version
	@ $(JAVA_ARCHIVE) --version
	@ make -v | head -n 1
	@ echo "makefile 0.1"

.PHONY: setup
setup:
	# ANTLR automatically creates $(ANTLR_OUT_DIR)
	mkdir -p $(ANTLR_IN_DIR) $(JAVA_COMP_IN_PRIMARY_DIR) $(JVM_IN_DIR)
	mkdir -p test deprecated  experiment  documentation temporary 

.PHONY: clean
clean:
	@if [ -n "$(JVM_IN_DIR)" ]; then \
	  echo "Cleaning $(JVM_IN_DIR)"; \
	  rm -rf $(JVM_IN_DIR)/*; \
	else \
	  echo "Warning: JVM_IN_DIR is not set"; \
	fi
	@if [ -n "$(ANTLR_OUT_DIR)" ]; then \
	  echo "Cleaning $(ANTLR_OUT_DIR)"; \
	  rm -rf $(ANTLR_OUT_DIR); \
	else \
	  echo "Warning: ANTLR_OUT_DIR is not set"; \
	fi
	@if [ -d "temporary" ]; then \
	  echo "Cleaning temporary directory"; \
	  rm -rf temporary/*; \
	else \
	  echo "Warning: temporary directory does not exist"; \
	fi

#================================================================================
# recipes

# ANTLR a run of any of these will make all the files
$(ANTLR_OUT_DIR)/%Lexer.java: $(ANTLR_IN_DIR)/%.g4
	@echo "making grammar from:" $<
	$(JAVA_INTERP) -jar $(ANTLR_JAR) -Dlanguage=Java -visitor -o $(ANTLR_OUT_DIR_PARENT) $<

$(ANTLR_OUT_DIR)/%Parser.java: $(ANTLR_IN_DIR)/%.g4
	@echo "making grammar from:" $<
	$(JAVA_INTERP) -jar $(ANTLR_JAR) -Dlanguage=Java -visitor -o $(ANTLR_OUT_DIR_PARENT) $<

$(ANTLR_OUT_DIR)/%BaseVisitor.java: $(ANTLR_IN_DIR)/%.g4
	@echo "making grammar from:" $<
	$(JAVA_INTERP) -jar $(ANTLR_JAR) -Dlanguage=Java -visitor -o $(ANTLR_OUT_DIR_PARENT) $<

$(ANTLR_OUT_DIR)/%Visitor.java: $(ANTLR_IN_DIR)/%.g4
	@echo "making grammar from:" $<
	$(JAVA_INTERP) -jar $(ANTLR_JAR) -Dlanguage=Java -visitor -o $(ANTLR_OUT_DIR_PARENT) $<

# Generic recipe for building .jar files and placing scripts in the executor directory
$(JAVA_COMP_OUT_DIR)/%.jar: $(JAVA_COMP_IN_PRIMARY_DIR)/%.java
	@echo "Building $*..."
	$(JAVA_COMP) -d $(JAVA_COMP_OUT_DIR) -sourcepath $(JAVA_COMP_IN_DL) $<
	$(JAVA_ARCHIVE) cf $@ -C $(JVM_IN_DIR) $*.class
	@echo "Creating script for $*..."
	echo "#!/usr/bin/env bash\n$(JAVA_INTERP) -cp $@ $*" > executor/$*.sh
	chmod +x executor/$*.sh

