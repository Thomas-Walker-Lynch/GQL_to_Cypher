//---------------------------------------------------------------------------------
// globals

// string comprehension includes for regular expressions
def base = "[a-zA-Z0-9_-]+"
def ext = "[a-zA-Z0-9_-]+$"
def name = "${base}\\.${ext}"
def path = ".+/${name}"

//--------------------------------------------------------------------------------
// Import variables from the environment
//

def env = [:]

// Required shell environment variables
def varName_List = [
  'REPO_HOME',
  'PROJECT',
  'ENV_BUILD_VERSION',
  'DEVELOPER_HOME'
]
varName_List.each { varName ->
  def value = System.getenv(varName) ?: ""
  env[varName] = value
}

// Optional shell environment variables
def varNameOptional_List = [
  'CLASSPATH'
]
varNameOptional_List.each { varName ->
  def value = System.getenv(varName) ?: ""
  env[varName] = value
}

env.CLASSPATH += ":${env.ANTLR_JAR}"

//--------------------------------------------------------------------------------
// PM installed tools to be used
//    these should be added to the project object by the installer ,and taken
//    from the project object here.
//
// Tools used (set by project manager: JAVA_HOME ,ANTLR_JAR ,DEVELOPER_HOME)
def JAVA_COMP_FP = "${env.JAVA_HOME}/bin/javac"   // Java compiler path
def JAVA_INTERP_FP = "${env.JAVA_HOME}/bin/java"  // Java interpreter path
def JAVA_ARCHIVE_FP = "${env.JAVA_HOME}/bin/jar"  // Java archive tool path


//--------------------------------------------------------------------------------
// Directory structure
//

def dir_map = [
  ,'EXECUTOR_IN'         : 'executor/'
  ,'ANTLR_IN_LEAF'       : 'ANTLR/'
  ,'ANTLR_OUT'           : 'javac/ANTLR/'
  ,'ANTLR_OUT_PARENT'    : 'javac/'
  ,'JAVA_COMP_IN'        : 'javac/'
  ,'JAVA_COMP_IN_LEAF': 'javac/leaf/'
  ,'JAVA_COMP_IN_ANTLR'  : 'javac/ANTLR/'
  ,'JAVA_COMP_IN_SYN'    : 'javac/synthesized/'
  ,'JAVA_COMP_OUT'       : 'jvm/'
  ,'JVM_IN'              : 'jvm/'
  ,'TEMP'                : 'Erebus/'
]

// Update CLASSPATH
env.CLASSPATH += ":${dir_map.JVM_IN}"

// Construct JAVA_COMP_IN_LIST dynamically and add to dp map
dir_map.JAVA_COMP_IN_LIST = 
  "${dir_map.JAVA_COMP_IN_LEAF}" +
  ":${dir_map.JAVA_COMP_IN_ANTLR}" +
  ":${dir_map.JAVA_COMP_IN_SYN}"

println "CLASSPATH: ${env.CLASSPATH}"
println "JAVA_COMP_IN_LIST: ${dir_map.JAVA_COMP_IN_LIST}"


// Subroutine to print missing environment variables list message
def printMissingVars(missingVars) {
  if (missingVars.isEmpty()) {
    // Print nothing if the list is empty
    return
  } else if (missingVars.size() == 1) {
    println "This environment variable was not set: ${missingVars[0]}"
  } else {
    println "These environment variables were not set: ${missingVars.join(' ,')}"
  }
}

task preface {
  dependsOn ':installTools'
  doFirst {
    
    // Environment variable checks
    def error_missing = false
    def error_project = false
    def missingVars = [] // To collect missing environment variables
    varName_List.each { varName ->
      if (!env[varName]) {
        error_missing = true
        missingVars << varName
      }
    }
    printMissingVars(missingVars)
    if (env.PROJECT != "GQL_to_Cypher") {
      error_project = true
      println "Expected project 'GQL_to_Cypher' ,but found '${env.PROJECT}'."
    }
    if (error_missing || error_project) {
      throw new GradleException("Bailing due to missing environment variables.")
    }
  }
  doLast {
    println "================================================================================"
    println "Building project .."
  }
}

/*--------------------------------------------------------------------------------
 Some dependency graph features
*/

def all_node_type_set = ['symbol' ,'path' ,'leaf'] as Set

def persistent_node_mark_set = ['cycle_member' ,'wellformed' ,'build_failed'] as Set

def leaf_q = { node -> node.type && node.type == 'leaf' }
def marked_q = { node -> node.mark && !node.mark.isEmpty() }

// 'wellformed' and `cycle_member` marks set by `well_formed_q` function
// 'build_failed' set by `run_build_scripts_f`
def marked_good_q(node){
  return (
    node 
    && node.mark 
    && ('wellformed' in node.mark) 
    && !('cycle_member' in node.mark)
    && !('build_failed' in node.mark)
  )
}

def set_mark(node ,mark){
  node.mark = node.mark ?: [] as Set
  node.mark << mark
}

def clear_mark(node ,mark){
  if( node.mark ) node.mark.remove(mark)
}

def file_exists_q(node_label) {
  def node_path = Paths.get(node_label)
  return Files.exists(node_path)
}


/*--------------------------------------------------------------------------------
 Well formed dependency graph node checker.

*/
def all_form_error_set = [
  'no_node_label'
  ,'no_such_node_type'
  ,'neighbor_property_value_not_a_list'
  ,'unregistered_mark'
  ,'symbol_has_build_code'
  ,'symbol_has_no_dependencies'
  ,'missing_required_build_code'
  ,'build_target_has_no_dependencies'
  ,'leaf_has_neighbor_property'
  ,'leaf_has_neighbor'
]
def wellformed_q = { node -> 
  def form_error_set = [] as Set

  if( 
    !node.label || node.label.length() == 0 
  ) 
    form_error_set << 'no_node_label'

  if( 
    !node.type || !(node.type in all_node_type_set) 
  ) 
    form_error_set << 'no_such_node_type'

  if(
    node.neighbor 
    && !(node.neighbor instanceof List)
  )
    form_error_set << 'neighbor_property_value_not_a_list'

  if( 
    node.mark
    && (node.mark instance of Set)
    && ! (node.mark.every {it in persistent_node_mark_set})
  ) 
    form_error_set << 'unregistered_mark'

  if( 
    node.type == "symbol" 
    && node.build
  )
    form_error_set << 'symbol_has_build_code'

  if( 
    node.type == "symbol" 
    && ( !node.neighbor || node.neighbor.isEmpty() )
  )
    form_error_set << 'symbol_has_no_dependencies'

  if( 
    node.type == "path" 
    && (!node.build || !(node.build instanceof Closure))
  )
    form_error_set << 'missing_required_build_code'

  if( 
    node.type == "path" 
    && ( !node.neighbor || node.neighbor.isEmpty() )
  )
    form_error_set << 'build_target_has_no_dependencies'

  if( 
    node.type == "symbol" 
    && ( node.neighbor || node.neighbor.isEmpty() )
  )
    form_error_set << 'symbol_has_no_dependencies'

  if( 
    node.type == "leaf" 
    && node.neighbor
  ){
    form_error_set << 'leaf_has_neighbor_property'
    if( !node.neighbor.isEmpty()  )
      form_error_set << 'leaf_has_neighbor'
  }

  return form_error_set
}


/*--------------------------------------------------------------------------------
 Dependency DAG definition.

 Programmers will add new entries here when adding new programs to be built.

 'node': a dictionary of properties.
 'file node': a path or leaf type node.
 'node file': the label of a path or leaf type node ,relative to the developer's directory.

 Node Properties:
 - type: The type of the node: 'leaf' ,'symbol' ,or 'path'.
 - label: Unique label. AKA ,the 'node file'.
 - neighbor: List of labels for the node's dependencies.
 - must_have: Files that should not be removed if the given node file is not removed.
 - build: For path type nodes ,code that builds the node.
 - mark: a set of 'mark' tokens optionally placed on a node

 DAG is defined through the 'lookup' function ,which when given a label ,returns
 a dictionary. Lookup uses a combination of a map keyed on the label ,and a list
 of label recognizer functions that each return a dictionary when a match is
 found. 

*/

def node_map = [

  "all" : [
    ,type: "symbol"
    ,neighbor: [
      "ANTLR_OUT_FL"
      ,"RuleNameList"
      ,"RuleNameListRegx"
      ,"Synthesize_SyntaxAnnotate"
      ,"Synthesize_SyntaxAnnotate_PrintVisitor"
      ,"Synthesize_SyntaxAnnotate_PrintVisitorMethod"
    ]
  ]

  "ANTLR_OUT_FL" : [
    ,type: "symbol"
    ,neighbor: ["${dir_map.EXECUTOR_IN}/ANTLR_OUT_FL"]
  ]

  ,"RuleNameList" : [
    ,type: "symbol"
    ,neighbor: ["${dir_map.EXECUTOR_IN}/RuleNameList"]
  ]

  ,"RuleNameListRegx" : [
    ,type: "symbol"
    ,neighbor: ["${dir_map.EXECUTOR_IN}/RuleNameListRegx"]
  ]

  ,"Synthesize_SyntaxAnnotate" : [
    ,type: "symbol"
    ,neighbor: [
      "${dir_map.JAVA_COMP_IN_LEAF}/StringUtils.java"
      ,"${dir_map.EXECUTOR_IN}/Synthesize_SyntaxAnnotate"
    ]
  ]

  "Synthesize_SyntaxAnnotate.class" : [
    type: 'path',  // It's a path type node
    neighbor: [
      "${dir_map.JAVA_COMP_IN_LEAF}/Synthesize_SyntaxAnnotate.java",  // Dependency
      "${dir_map.JAVA_COMP_IN_LEAF}/StringUtils.java"  // Dependency
    ],
    build: { node, neighbor ->
      def javac_cmd = "${JAVA_COMP_FP} -d ${dir_map.JAVA_COMP_OUT} ${neighbor.join(' ')}"
      javac_cmd.execute().waitFor()
    }
  ]


  "Synthesize_SyntaxAnnotate.class" : [
    type: "path",
    neighbor: [
      "${dir_map.JAVA_COMP_IN_SYN}/Synthesize_SyntaxAnnotate.java"
    ],
    build: { node ->
      def src = "${dir_map.JAVA_COMP_IN_SYN}/Synthesize_SyntaxAnnotate.java"
      def dest = "${dir_map.JAVA_COMP_IN_SYN}/Synthesize_SyntaxAnnotate.class"
      exec {
        commandLine = [JAVA_COMP_FP, '-d', dir_map.JAVA_COMP_OUT, src]
      }
      if (!file_exists_q(dest)) {
        throw new GradleException("Failed to compile Synthesize_SyntaxAnnotate.java")
      }
    }
  ]



  ,"Synthesize_SyntaxAnnotate_PrintVisitor" : [
    ,type: "symbol"
    ,neighbor: [
      "${dir_map.JAVA_COMP_IN_LEAF}/StringUtils.java"
      ,"${dir_map.JAVA_COMP_IN_LEAF}/Synthesize_SyntaxAnnotate_PrintVisitorMethod.java"
      ,"${dir_map.EXECUTOR_IN}/Synthesize_SyntaxAnnotate_PrintVisitor"
    ]
  ]

  ,"Synthesize_SyntaxAnnotate_PrintVisitorMethod" : [
    ,type: "symbol"
    ,neighbor: [
      "${dir_map.JAVA_COMP_IN_LEAF}/StringUtils.java"
      ,"${dir_map.EXECUTOR_IN}/Synthesize_SyntaxAnnotate_PrintVisitorMethod"
    ]
  ]
]

// start of node_label recognizer functions list

// recognizes any leaf node due to being located in javac/leaf
def node_leaf_f(node_label) {
  def leafNodePattern = ~/${dir_map['JAVA_COMP_IN_LEAF']}(.*)/
  def match = node_label =~ leafNodePattern
  if (!match) {
    return [status: "no_match"]
  }
  def baseName = match[0][1]

  def leafFilePath = "${dir_map['JAVA_COMP_IN_LEAF']}${baseName}"
  def leafFile = new File(leafFilePath)
  if (!leafFile.exists()) {
    return [status: "no_match"]
  }

  return [
    status: "matched"
    ,label: node_label
    ,type: "leaf"
    ,neighbor: []
  ]
}

// any shell wrapper (for wrapping a name corresponding .jar file)
def node_executor_f(node) {

  def match = node =~ /^(executor\/)(${base})$/
  if (!match) {
    return [status: "no_match"]
  }
  def baseName = match[0][2]

  def jarFilePath = "${dir_map['JVM_IN']}${baseName}.jar"
  def wrapperFilePath = "${dir_map['EXECUTOR_IN']}${baseName}"

  def jarFile = new File(jarFilePath)
  if (!jarFile.exists()) {
    return [status: "no_match"]
  }

  return [
    status: "matched"
    ,label: node
    ,type: "path"
    ,neighbor: [jarFilePath]
    ,must_have: [jarFilePath]
    ,build: { node ,neighbor -> 

      // The script for wrapping the jar file:
      def wrapper =
      """
      #!/usr/bin/env bash
      ${dir_map['JAVA_INTERP']} -cp \${CLASSPATH}:${dir_map['JVM_IN']}:${dir_map['JVM_IN']}/${baseName}.jar ${baseName} \\\$\\@
      """
      
      new File(wrapperFilePath).withWriter('UTF-8') { writer ->
        writer.write(wrapper)
      }

      println "Creating executable wrapper script for ${baseName} in executor directory."
      "chmod +x ${wrapperFilePath}".execute().text
    }
  ]
}

// any antlr output java file
def node_grammar_f(node) {

  def match = node =~ /^(${dir_map['ANTLR_OUT']})(${base})(Lexer|Parser|BaseListener|Listener|BaseVisitor|Visitor)\.java$/
  if( !match ){
    return [status: "no_match"]
  }

  def grammarName = match[0][2]
  def outputType = match[0][3]

  def grammarFilePath = "${dir_map['ANTLR_IN_LEAF']}${grammarName}.g4"
  def grammarFile = new File(grammarFilePath)

  if( !grammarFile.exists() ){
    return [status: "no_match"]
  }

  return [
    status: "matched"
    ,label: node
    ,type: "path"
    ,neighbor: [grammarFilePath]
  ]
}

// Recognizes any class file (built from a corresponding .java file of the same name)
def node_class_f(node) {

  def match = node =~ /^(${dir_map['JAVA_COMP_OUT']})(${base})\.class$/
  if( !match ){
    return [status: "no_match"]
  }

  def baseName = match[0][2]
  def javaFilePath = "${dir_map['JAVA_COMP_IN_PRIMARY_DIR']}/${baseName}.java"
  def javaFile = new File(javaFilePath)

  if( !javaFile.exists() ){
    return [status: "no_match"]
  }

  return [
    status: "matched",
    label: node,
    type: "path",  // It's a path node since we're building the .class file
    neighbor: [javaFilePath],  // The corresponding .java file
    build: { node, neighbor ->
        def javac_cmd = "${JAVA_COMP_FP} -d ${dir_map.JAVA_COMP_OUT} -sourcepath ${dir_map.JAVA_COMP_IN_DL} ${neighbor[0]}"
        javac_cmd.execute().waitFor()
    }
  ]
}

// any jar file (built from a corresponding class file)
def node_jar_f(node) {

  // Use the symbolic name and base patterns
  def match = node =~ /^(${dir_map['JAVA_COMP_OUT']})(${base})\.jar$/

  if( !match ){
    return [status: "no_match"]
  }

  def baseName = match[0][2]
  def classFilePath = "${dir_map['JAVA_COMP_OUT']}${baseName}.class"
  def classFile = new File(classFilePath)

  if( !classFile.exists() ){
    return [status: "no_match"]
  }

  return [
    status: "matched"
    ,label: node
    ,type: "path"
    ,neighbor: [classFilePath]
    ,build: { node ,neighbor ->
      println "Building jar for ${baseName}"
      def command = "${ext.javaHome}/bin/jar cf ${baseName}.jar -C ${dir_map['JAVA_COMP_OUT']} ${baseName}.class"
      return command.execute().text;
    }
  ]
}

// list of the recognizer functions
def node_f_list = [
  node_leaf_f
  ,node_executor_f
  ,node_grammar_f
  ,node_class_f
  ,node_jar_f
]

// end of DAG definition

/*--------------------------------------------------------------------------------
 Given a node_label ,returns the node or null.

*/
def lookup(node_label ,verbose = false){
  def lookup_node = node_map[node_label]
  if( lookup_node ){
    lookup_node.label = node_label
  } else {
    def match_result
    for(func in node_f_list){
      match_result = func(node_label)
      if(match_result.status == "matched"){
        lookup_node = match_result
        break
      }
    }
  }
  if( !lookup_node ){
    if( verbose ) println "lookup:: Node ${node_label} could not be found."
    return null
  }
  return lookup_node
}

// mark aware lookup function
def lookup_marked_good(node_label ,verbose = false){
  def node = lookup(node_label ,verbose)
  if( node && marked_good_q(node) ) return node;
  return null;
}

/*--------------------------------------------------------------------------------
 A well formed graph checker.  Traverses entire graph and marks nodes
 that are not well formed or that are part of a cycle.

 This must be run on the graph for `lookup_marked_good` to work.
*/

/*
 Given a node label list. Applies well_formed_q to each node and marks the
 node accordingly. Returns 'all_wellformed' or 'exists_malformed'.
*/
def mark_the_wellformed_f(node_label_list ,boolean verbose = true){
  def all_wellformed = true

  def neighbors = node_label_list.collect{ neighbor_label ->
    def neighbor_node = lookup(neighbor_label)
    def form_errors = wellformed_q(neighbor_node)
    if(form_errors.isEmpty()){
      neighbor_node.mark = neighbor_node.mark ?: [] as Set
      neighbor_node.mark << 'wellformed'
    } else {
      all_wellformed = false
      if(verbose){
        if(neighbor_node.label && neighbor_node.label.length() > 0){
          print("node ${neighbor_node.label} is malformed due to:")
        } else {
          print("anonymous node is malformed due to:")
        }
        form_errors.each { error -> print(" ${error}") }
        println("")
      }
    }
    neighbor_label
  }

  return all_wellformed ? 'all_wellformed' : 'exists_malformed'
}

/*
 Given a path stack initialized with the path root ,descends to a leaf node
 while looking for cycles. Marks nodes as 'cycle_member' if a cycle is
 detected. Marks nodes as `wellformed` if `wellformed_q`.  Returns a set of
 tokens indicating the status: 'cycle_found' ,'defacto_leaf_node' ,and
 'exists_malformed'.
*/
def markup_graph_f_descend(path_stack ,boolean verbose = true){
  def ret_value = [] as Set
  def local_path = path_stack.collect{ it[0] }
  def local_node_label = local_path[-1]
  def cycle_start_index

  do{
    // Check for a cycle in the local path
    cycle_start_index = local_path[0..-2].findIndexOf{ it == local_node_label }
    if(cycle_start_index != -1){ // Cycle detected
      ret_value << 'cycle_found'
      if(verbose) print "markup_graph_f_descend:: dependency cycle found:"
      local_path[cycle_start_index..-1].each{ cycle_node_label ->
        def cycle_node = lookup(cycle_node_label)
        if(verbose) print " ${cycle_node.label}"
        cycle_node.mark = cycle_node.mark ?: [] as Set // Initialize mark set if needed
        cycle_node.mark << 'cycle_member'
      }
      if(verbose) println ""
      // we can not continue searching after the loop so ,we pop back to treat
      // the first node in the loop as though a leaf node.
      path_stack = path_stack[0..cycle_start_index]
      return ret_value
    }

    // a 'de-facto' leaf node test subtleties here because we have not yet
    // determined if the nodes we are wellformed. This is purposeful ,as
    // this function does not know about the relationships between the 
    // possible error marks.
    def local_node = lookup(local_node_label)
    if(local_node.neighbor.isEmpty()){
      ret_value << 'defacto_leaf_node'
      return ret_value
    }

    // Mark the wellformed nodes and get the result
    def result = mark_the_wellformed_f(local_node.neighbor ,verbose)
    if(result == 'exists_malformed'){
      ret_value << 'exists_malformed'
    }
    
    // Descend further into the tree.
    path_stack << local_node.neighbor.clone()
    local_node_label = local_node.neighbor[0]
    local_path << local_node_label
  }while(true)
}

/*
 Given root_node_labels ,marks up the graph and returns a set possibly
 containing 'all_wellformed' and 'cycles_exist'.

 Marks potentially added to each node include  'cycle_member' ,'wellformed'.
 Note that these marks are independent.
*/
def wellformed_graph_q(root_node_labels ,boolean verbose = true){
  def ret_value = [] as Set
  def exists_malformed = false;

  // check the root nodes
  def result = mark_the_wellformed_f(root_node_labels ,verbose)
  if(result == 'exists_malformed'){
    ret_value << 'exists_malformed'
  }

  // Initialize the DFS tree iterator.
  def path_stack = []
  path_stack << root_node_labels.clone()

  // iterate over left side tree descent ,not ideal as it starts at the
  // root each time ,but avoids complexity in the cycle detection logic.
  do{
    def result = markup_graph_f_descend(path_stack ,verbose)
    if('cycle_found' in result) ret_value << 'cycle_exists'
    if('exists_malformed' in result) exists_malformed = true;

    // increment the iterator to the next leftmost path
    def top_list = path_stack[-1]
    top_list.remove(0)
    if(top_list.isEmpty()) path_stack.pop()

  }while(!path_stack.isEmpty())

  if(!exists_malformed) ret_value << 'all_wellformed'
  if( verbose ){
    if(exists_malformed) println("one or more malformed nodes were found")
    def exists_cycle = 'cycle_found' in ret_value
    if(exists_cycle) println("one or more cyclic dependency loop found")
    if( exists_malformed || exists_cycle ) println("will attempt to build unaffected nodes")
  }

  return ret_value
}


/*
 Given `root_node_labels` of a DAG. Applies `node_function` to each node in a
 depth-first traversal order.  Returns a set of error tokens encountered
 during traversal.

 `wellformed_graph_q` must be run on the DAG before this function is called ,or
 `lookup_marked_good` will not function correctly.
*/
def all_DAG_DF(root_node_labels ,node_function ,boolean verbose = true) {
  def error_token_set = [] as Set

  if (root_node_labels.isEmpty()) return error_token_set

  def visited = [] as Set
  def in_traversal_order = []
  def stack = []

  root_node_labels.each { root_label ->
    stack << root_label
  }

  do {
    def node_label = stack.pop()
    
    def node = lookup_marked_good(node_label ,verbose)
    if (!node) {
      error_token_set << 'lookup_fail'
      continue
    }

    if (node.label in visited) continue
    visited << node.label

    in_traversal_order << node

    node.neighbor.each { neighbor_label ->
      stack << neighbor_label
    }
  } while (!stack.isEmpty())

  in_traversal_order.reverse().each { node ->
    node_function(node ,error_token_set ,verbose)
  }

  return error_token_set
}


/*--------------------------------------------------------------------------------
 run the build scripts
   depends upon is_acyclic having already marked up the graph.
*/

import java.nio.file.Files
import java.nio.file.Paths

// a symbol dependency is good ,as long as it is built before the node in question
def good_dependency_q(node_labels) {
  return node_labels.every { node_label ->
    def node = lookup_marked_good(node_label)
    if (!node) return false
    if (node.type in ['path' ,'leaf'] && !file_exists_q(node.label)) return false
    return true
  }
}

/* 
 Given a node label and a list of node labels ,returns true if the file at the
 node label in the first argument is newer than all the files at the
 corresponding node labels in the second list.
*/
def newer_than_all(node_label ,node_label_list) {
  def node_path = Paths.get(node_label)
  if (!Files.exists(node_path)) return false

  def node_last_modified = Files.getLastModifiedTime(node_path).toMillis()

  return node_label_list.every { label ->
    def path = Paths.get(label)
    if (!Files.exists(path)) return false
    def last_modified = Files.getLastModifiedTime(path).toMillis()
    return node_last_modified > last_modified
  }
}

def can_be_built_q(node){
  if( !marked_good_q(node) ) return false;
  if( 
    (node.type == 'symbol' || type == 'path')
    && !good_dependency_q( node.neighbor )
  ){
    return false
  }
  if(
    node.type == 'leaf'
    && !file_exists_q(node.label)
  ){ 
    return false;
  }
  return true
}

// `can_be_build_q` must be true for this to be meaningful:
def should_be_built_q(node ,verbose = true) {
  if(node.type == 'leaf') return false
  if(node.type == 'symbol') return true
  if( node.type == 'path') return !newer_than_all(node.label ,node.neighbor)
  println("should_be_build_q:: unrecognized node type ,so assuming it should not be built.")
  return false
}

/*
 Runs build scripts for the given root_node_labels in a depth-first traversal order.
 Uses `all_DAG_DF` to traverse the graph and applies the build function to each node.

 Be sure that `wellformed_graph_q` has been run on DAG.

 Be sure that the 'build_failed' marks have been cleared if this is not the
 first build attempt.
 
*/
def run_build_scripts_f(root_node_labels ,boolean verbose = true){
  if( root_node_labels.isEmpty() ) return

  // Define the function to be applied to each node
  def node_function = { node ,error_token_set ->

    if( !can_be_built_q(node) ){
      println("Skipping build for ${node.label} due to dependency problems or found leaf is missing")
      return
    }

    if( !should_be_built_q(node) ){
      if(verbose) println("${node.label} already up to date")
      return
    }

    // if we get here, node can and should be built

    println("Running build script for ${node.label}")
    node.build(node ,node.neighbor)

    // Check if the build updated the target file
    if( should_be_built_q(node) ){
      println("Build failed for ${node.label}")
      set_mark(node ,'build_failed')
    }

  }

  // Apply the function to all nodes in a depth-first manner
  all_DAG_DF(root_node_labels ,node_function ,verbose)
}

 

------------------------------------

def run_build_scripts_f( root_node_labels ,boolean verbose = true ){
  if( root_node_labels.isEmpty() ) return

  def visited = [] as Set
  def build_order = []
  def stack = []

  root_node_labels.each{ root_label ->
    stack << root_label
  }

  do{
    def node_label = stack.pop()
    def node = lookup( node_label ,verbose )
    if( !node ) continue

    if( node.label in visited ) continue
    visited << node.label

    if( !marked_good_q( node ) ){
      if( verbose ) println( "Skipping malformed node ${node.label}" )
      continue
    }

    // Clear the build_failed mark
    node.mark.remove( 'build_failed' )

    // reverse to be consistent in using the left subtree first
    node.neighbor.reverse().each{ neighbor_label ->
      stack << neighbor_label
    }

    build_order << node
  }while( !stack.isEmpty() )

  build_order.reverse().each{ node ->
    def build_status = build_status_q( node ,verbose )
    if( build_status == 'should_build' ){
      println( "Running build script for ${node.label}" )
      node.build( node ,node.neighbor )

      // Check if the build updated the target file
      if( build_status_q( node ,verbose ) == 'should_build' ){
        println( "Build failed for ${node.label}" )
        node.mark = node.mark ?: [] as Set
        node.mark << 'build_failed'
      }
    } else if( build_status == 'dependency_problem' ){
      println( "Skipping build for ${node.label} due to dependency problems" )
    } else if( build_status == 'leaf' ){
      println( "Skipping build for leaf node ${node.label}" )
    }
  }
}


--------------------------------------------------------------------------------
def clean(nodes_to_clean) {
  def all_dependencies = node_map["all"].neighbor.clone()
  nodes_to_clean.each { node ->
    all_dependencies.remove(node)
  }

  def must_have_nodes = []
  all_dependencies.each { node ->
    def node_info = node_map[node]
    if (node_info.must_have) {
      must_have_nodes += node_info.must_have
    }
  }

  def to_clean_list = []
  nodes_to_clean.each { node ->
    if (!must_have_nodes.contains(node) && node_map[node].type == "path") {
      to_clean_list += node
    }
  }

  to_clean_list.each { node ->
    def file_path = node_map[node].label
    def file = new File(file_path)
    if (file.exists()) {
      file.delete()
      println "Deleted file: ${file_path}"
    }
  }
}


--------------------------------------------------------------------------------
def mark_for_clean_q( node ){
  if( node.type == 'leaf' ) return false

  if( node.type == 'symbol' || node.type == 'path' ){
    def dependencies = node.neighbor.findAll{ neighbor_label ->
      def neighbor_node = lookup( neighbor_label )
      return good_dependency_q( neighbor_node )
    }
    return dependencies.size() == node.neighbor.size()
  }

  return false
}

def clean_nodes(root_node_labels ,boolean verbose = true){
  if( root_node_labels.isEmpty() ) return

  def visited = [] as Set
  def clean_order = []
  def stack = []

  root_node_labels.each{ root_label ->
    stack << root_label
  }

  do{
    def node_label = stack.pop()
    def node = lookup( node_label ,verbose )
    if( !node ) continue

    if( node.label in visited ) continue
    visited << node.label

    if( !marked_good_q( node ) ){
      if( verbose ) println( "Skipping malformed node ${node.label}" )
      continue
    }

    // reverse to be consistent in using the left subtree first
    node.neighbor.reverse().each{ neighbor_label ->
      stack << neighbor_label
    }

    clean_order << node
  }while( !stack.isEmpty() )

  clean_order.reverse().each{ node ->
    if( mark_for_clean_q( node ) ){
      def can_clean = true
      node.uses?.each{ used_label ->
        def used_node = lookup( used_label )
        if( used_node && !mark_for_clean_q( used_node ) ){
          can_clean = false
          if( verbose ) println( "Cannot clean ${node.label} because it uses ${used_node.label}" )
        }
      }
      if( can_clean ){
        println( "Cleaning node ${node.label}" )
        node.clean( node ,node.neighbor )
      } else {
        if( verbose ) println( "Skipping node ${node.label} due to dependency problems" )
      }
    } else if( node.type == 'leaf' ){
      if( verbose ) println( "Skipping leaf node ${node.label}" )
    } else {
      if( verbose ) println( "Skipping node ${node.label} due to dependency problems" )
    }
  }
}


// LocalWords:  FN FPL DN DNL RuleNameListRegx RuleNameList PrintVisitorMethod
// LocalWords:  PrintVisitor SyntaxAnnotate wellformed defacto acyclic
