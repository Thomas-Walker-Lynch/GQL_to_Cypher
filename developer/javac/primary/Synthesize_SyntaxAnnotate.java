import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class Synthesize_SyntaxAnnotate {
  // Constant for the usage message
  private static final String USAGE_MESSAGE = 
    "Usage: Synthesize_SyntaxAnnotate [-version] <grammar-name> <output-file-path>";

  public static void main(String[] args) throws IOException {
    if (args.length == 0) {
      System.err.println(USAGE_MESSAGE);
      System.exit(1);
    }
    boolean error = false;
    boolean version = false;
    List<String> argList = new ArrayList<>();
    for (int i = 0; i < args.length; i++) {
      String arg = args[i];
      if (arg.startsWith("-")) {
        switch (arg) {
        case "-version":
          version = true;
          break;
        default:
          System.err.println("Unrecognized option: " + arg);
          error = true;
        }
      } else {
        argList.add(arg);
      }
    }
    if(version){
      System.out.println("version 0.1");
      if(error){
        System.exit(1);
      }else{
        System.exit(0);
      }        
    }
    if (argList.size() != 2) {
      System.err.println("Expected exactly two non-option arguments.");
      error = true;
    }
    if(error){
      System.err.println(USAGE_MESSAGE);
      System.exit(1);
    }

    String grammarName = argList.get(0);
    // in case the user provided a path instead of a name:
    grammarName = Paths.get(grammarName).getFileName().toString().replace(".g4", "");

    String outputFile = argList.get(1);

    synthesizeSyntaxAnnotateClass(grammarName, outputFile);
  }

  private static void synthesizeSyntaxAnnotateClass(String grammarName, String outputFile) throws IOException {
    String className = grammarName + "_SyntaxAnnotate";
    String lexerName = grammarName + "Lexer";
    String parserName = grammarName + "Parser";
    String visitorName = grammarName + "_SyntaxAnnotate_PrintVisitor";

    // Template for the SyntaxAnnotate class
    String classTemplate = """
      /* This file generated by Synthesize_SyntaxAnnotate given the grammar 
         name: ____4_.
         
         SyntaxAnnotate programs accept a source file, then echo the source file with
         syntax annotation. Synthesize_SyntaxAnnotate produces a SyntaxAnnotate program
         for a specific grammar.
       */
      import org.antlr.v4.runtime.*;
      import org.antlr.v4.runtime.tree.*;
      import java.io.IOException;
      import java.nio.file.Files;
      import java.nio.file.Paths;
      import java.util.ArrayList;
      import java.util.List;

      public class ____0_ {
        // Constant for the usage message
        private static final String USAGE_MESSAGE =
          "Usage: ____0_ [-version] [-pp] <source-file-path>";

        public static void main(String[] args) throws IOException {
          if (args.length == 0) {
            System.err.println(USAGE_MESSAGE);
            System.exit(1);
          }
          boolean error = false;
          boolean version = false;
          boolean pretty_print = false;
          List<String> argList = new ArrayList<>();
          for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.startsWith("-")) {
              switch (arg) {
              case "-version":
                version = true;
                break;
              case "-pp":
                pretty_print = true;
                break;
              default:
                System.err.println("Unrecognized option: " + arg);
                error = true;
              }
            } else {
              argList.add(arg);
            }
          }
          if(version){
            System.out.println("version 0.1");
            if(error){
              System.exit(1);
            }else{
              System.exit(0);
            }        
          }
          if (argList.size() != 1) {
            System.err.println("Expected exactly one non-option argument.");
            error = true;
          }
          if(error){
            System.err.println(USAGE_MESSAGE);
            System.exit(1);
          }

          String input_file = argList.get(0);
          String input = Files.readString(Paths.get(input_file));

          try {
            ____1_ lexer = new ____1_(CharStreams.fromString(input));
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            ____2_ parser = new ____2_(tokens);
            ParseTree tree = parser.program();

            ____3_ visitor = new ____3_(parser.getRuleNames(), pretty_print);
            String output = visitor.visit(tree);
            System.out.println(output);
          } catch (Exception e) {
            e.printStackTrace();
          }
        }
      }
      """;

    // Fill in the blanks in the template
    classTemplate = classTemplate.replace("____0_", className);
    classTemplate = classTemplate.replace("____1_", lexerName);
    classTemplate = classTemplate.replace("____2_", parserName);
    classTemplate = classTemplate.replace("____3_", visitorName);
    classTemplate = classTemplate.replace("____4_", grammarName);

    // Write the synthesized class to the output file
    Files.writeString(Paths.get(outputFile), classTemplate);
  }
}

//  LocalWords:  SyntaxAnnotate
